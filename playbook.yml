---
  ######################################
  # BASIS SETUP
  ######################################
- name: basic system setup
  hosts: all_hosts
  user: admin
  become: true
  become_method: doas

  tasks:
  - name: configure hosts file
    blockinfile:
      dest: /etc/hosts
      block: |
          127.0.0.1         localhost
          ::1               localhost
          46.36.36.48       node2   node2.wurstbot.com
          80.240.28.59      node3   node3.wurstbot.com
          45.32.152.181     node4   node4.wurstbot.com
          45.32.185.50      node5   node5.wurstbot.com
          209.250.244.111   node6   node6.wurstbot.com
      marker: "# {mark} ANSIBLE MANAGED BLOCK - hosts config"
      state: present
      backup: yes
      create: True

  - name: create adduser config
    blockinfile:
      dest: /etc/adduser.conf
      block: |
          verbose = 1
          defaultpasswd = "yes"
          encryptionmethod = "auto"
          dotdir = "/etc/skel"
          send_message = "no"
          message_file = "/etc/adduser.message"
          config = "/etc/adduser.conf"
          logfile = "/var/log/adduser"
          home = "/home"
          path = ('/bin', '/usr/bin', '/usr/local/bin')
          shellpref = ('csh', 'sh', 'bash', 'tcsh', 'ksh', 'nologin')
          defaultshell = "ksh"
          defaultgroup = "USER"
          uid_start = 1000
          uid_end = 2147483647
          defaultclass = "default"
          login_classes = ('default', 'daemon', 'staff', 'authpf', 'pbuild', 'bgpd', 'unbound', 'dovecot')
      marker: "# {mark} ANSIBLE MANAGED BLOCK - adduser config"
      state: present
      backup: yes
      create: True

  - name: create admin user with password
    shell: pass=$(echo {{ admin_pass }} | encrypt) ; adduser -batch {{ admin_user }} wheel 'admin' $pass
    ignore_errors: true
    no_log: true

  - name: set admin user password
    shell: pass=$(echo {{ admin_pass}} | encrypt) ; usermod -p $pass {{ admin_user }}
    no_log: true

  - name: set install url
    lineinfile:
      dest: /etc/installurl
      backup: yes
      line: "{{ install_url }}"
      state: present
      create: True

  - name: set default profile
    blockinfile:
      dest: /etc/profile
      backup: yes
      block: |
        HISTFILE=$HOME/.history
        HISTSIZE=500
        PATH=$PATH:/usr/local/bin:/usr/local/sbin
      marker: "# {mark} ANSIBLE MANAGED BLOCK - profile config"
      state: present
      create: True

  - name: forward root mails to admin
    blockinfile:
      dest: /etc/mail/aliases
      backup: yes
      block: |
        root: {{ admin_email }}
        _nagios: {{ admin_email }}
        nagios: {{ admin_email }}
        _zabbix: {{ admin_email }}
        zabbix: {{ admin_email }}
      state: present
      create: True
      marker: "# {mark} ANSIBLE MANAGED BLOCK - aliases config"
    register: admin_email_result

  - name: activate forward root mails change
    shell: newaliases
    when: admin_email_result|changed

  - name: cron - system patches
    cron:
      name: "install system patches"
      special_time: weekly
      job: "syspatch"

  - name: cron - package updates
    cron:
      name: "install package updates"
      special_time: weekly
      job: "pkg_add -u"

  - name: cron - refresh certs with acme-client
    cron:
      name: "refresh certs with acme-client"
      special_time: weekly
      job: "acme-client {{ dns_name }} && rcctl reload httpd"

  - name: cron - refresh ocsp with ocspcheck
    cron:
      name: "refresh ocsp with ocspcheck"
      special_time: daily
      job: "ocspcheck -vN -o /etc/ssl/{{ dns_name }}.der /etc/ssl/{{ dns_name }}.fullchain.pem"

  - name: cron - create zabbix agentd pid files and restart zabbix agent at reboot
    cron:
      name: "create zabbix agent pid files"
      special_time: reboot
      job: "touch /var/run/zabbix_agentd.pid ; chown _zabbix:_zabbix /var/run/zabbix_agentd.pid ; rcctl restart zabbix_agentd"

  - name: cron - create zabbix server pid files and restart zabbix server at reboot
    cron:
      name: "create zabbix server pid files"
      special_time: reboot
      job: "touch /var/run/zabbix_server.pid ; chown _zabbix:_zabbix /var/run/zabbix_server.pid ; rcctl restart zabbix_server"

  - name: cron - create zabbix proxy pid files and restart zabbix proxy at reboot
    cron:
      name: "create zabbix proxy pid files"
      special_time: reboot
      job: "touch /var/run/zabbix_proxy.pid ; chown _zabbix:_zabbix /var/run/zabbix_proxy.pid ; rcctl restart zabbix_proxy"

  #######################################
  # UPDATE SYSTEM AND PACKAGES
  #######################################
- name: install system updates
  hosts: all_hosts
  user: admin
  become: true
  become_method: doas

  tasks:
    # - name: list available system updates
    #   shell: syspatch -c

    - name: install system updates
      shell: syspatch
      register: system_update_results
      when: update_mode==True

    - name: install package updates
      shell: pkg_add -u
      register: package_update_results
      when: update_mode==True

    - name: install extra packages
      openbsd_pkg: name={{ item }} state=present
      with_items: "{{ extra_packages }}"
      register: extra_packages_result

  #######################################
  # SYSCTL
  #######################################
- name: configure sysctl
  hosts: all_hosts
  user: admin
  become: true
  become_method: doas

  tasks:
  - name: sysctl - configure kernel options
    blockinfile:
      dest: /etc/sysctl.conf
      block: |
        kern.shminfo.shmmax=134217728         # max size of shared memory segment (bytes)
        kern.shminfo.shmall=524288            # total amount of sharedmemory available (pages)
        kern.shminfo.shmmni=240               # max number of sharedmemory segments system-wide
        # for zabbix agent, double semaphore count - fixes cannot open log: cannot create semaphore set
        kern.seminfo.semmns=240               # max number ofsemaphores system-wide
        #IPv6
        net.inet.ip.forwarding=1
        net.inet6.ip6.forwarding=1
        net.inet6.ip6.redirect=1
        # reboot automatically after kernel panic
        ddb.panic=0

      marker: "# {mark} ANSIBLE MANAGED BLOCK - sysctl config"
      create: true
      backup: yes

  #######################################
  # DOAS
  #######################################
- name: configure doas
  hosts: all_hosts
  user: admin
  become: true
  become_method: doas

  tasks:
  - name: doas - configure options
    lineinfile:
      dest: /etc/doas.conf
      line: permit nopass setenv { -ENV PS1=$DOAS_PS1 SSH_AUTH_SOCK } :wheel
      backup: yes
      state: present
      create: true

  #######################################
  # PF
  #######################################
- name: configure pf
  hosts: all_hosts
  user: admin
  become: true
  become_method: doas

  tasks:
  - name: pf - configure packet filter
    blockinfile:
      dest: /etc/pf.conf
      block: |
            queue main on {{ ext_if }} bandwidth 10M
            queue def parent main bandwidth 10M default

            # choke abusers in a very slow queue
            queue choke parent main bandwidth 1K min 0K max 1K qlimit 300

            table <abusers> persist counters
            table <flooders> persist counters
            table <ha_flooders> persist counters

            #allow 169.254.0.0/16 for bgp
            table <martians> { 0.0.0.0/8 10.0.0.0/8 127.0.0.0/8 \
                               172.16.0.0/12 192.0.0.0/24 192.0.2.0/24 224.0.0.0/3 \
                               192.168.0.0/16 198.18.0.0/15 198.51.100.0/24        \
                               203.0.113.0/24 }

            #block return    # block stateless traffic
            pass            # establish keep-state

            # By default, do not permit remote connections to X11
            block return in on ! lo0 proto tcp to port 6000:6010

            set block-policy drop
            set loginterface pflog0
            antispoof for lo0
            set skip on lo0

            match in all scrub (no-df random-id max-mss 1440)
            block in from no-route to any
            block in from urpf-failed to any
            block in quick on egress from <martians> to any
            block return out quick on egress from any to <martians>

            block drop log (all) quick from <abusers>

            block log all

            pass out log quick inet
            pass in on egress inet proto icmp from any to any

            # abusive usage
            ###########################
            # allow traffic from abusers to egress but throttle them
            pass in quick log on egress proto tcp from <flooders> to (egress) port { {{ all_hosts_ports | join(', ') }} } flags S/SA keep state \
            (max-src-conn 1, max-src-conn-rate 1/1, overload <abusers> flush global, pflow) set queue choke

            # allow traffic from abusers to our ha ip but throttle them
            pass in quick log on {{ ext_if }} proto tcp from <ha_flooders> to {{ bgp_ha_ip }} port { {{ trusted_ha_hosts_ports | join(', ') }} } flags S/SA keep state \
            (max-src-conn 1, max-src-conn-rate 1/1, overload <abusers> flush global, pflow) set queue choke

            # regular rules
            ###########################
            # allow traffic from any hosts on web and monitoring ports
            pass in log on egress inet proto tcp from any to (egress) port { {{ all_hosts_ports | join(', ') }} } flags S/SA keep state \
            (max-src-conn 5, max-src-conn-rate 15/5, overload <flooders> flush global, pflow) queue def

            # allow traffic from known hosts on some ports. no rate limiting except from default queue.
            pass in log on egress inet proto tcp from { {{ trusted_hosts | join(', ') }} } to (egress) port { {{ trusted_hosts_ports | join(', ') }}  } queue def

            # allow traffic from any hosts to ha ip on some ports. with rate limiting.
            pass in log on {{ ext_if }} inet proto tcp from any to {{ bgp_ha_ip }} port { {{ trusted_ha_hosts_ports | join(', ') }} } flags S/SA keep state \
            (max-src-conn 5, max-src-conn-rate 15/5, overload <ha_flooders> flush global, pflow) queue def

      marker: "# {mark} ANSIBLE MANAGED BLOCK - pf config"
      backup: yes
      validate: "/sbin/pfctl -n -f %s"

  - name: pf - check conf
    shell: pfctl -nf /etc/pf.conf
    register: pf_result

  - name: pf - activate pf
    shell: pfctl -f /etc/pf.conf
    when: pf_result is succeeded

  #######################################
  # IKED
  #######################################
- name: configure iked
  hosts: iked_hosts
  user: admin
  become: true
  become_method: doas

  tasks:
  - name: iked - configure iked tunnels
    blockinfile:
      dest: /etc/iked.conf
      block: |
          ikev2 {{ vpn_name }} active esp \
            proto tcp from {{ vpn_local_ip }} \
            to {{ vpn_remote_ip }} \
            peer {{ vpn_peer_ip }} \
            psk {{ vpn_psk }}
      marker: "# {mark} ANSIBLE MANAGED BLOCK - iked config"
      backup: yes
      validate: "/sbin/iked -n -f %s"
      create: true
    register: iked_result

  - name: pf - configure packet filter iked
    blockinfile:
      dest: /etc/pf.conf
      owner: root
      mode: 600
      block: |
          queue iked parent main bandwidth 2M
          pass in log on {{ ext_if }} proto udp from {{ vpn_peer_ip }} to {{ vpn_local_ip }} port {500, 4500} set queue iked
          pass out log on {{ ext_if }} proto udp from {{ vpn_local_ip }} to {{ vpn_peer_ip }} port {500, 4500} set queue iked
          pass in log on {{ ext_if }} proto esp from {{ vpn_remote_ip }} to {{ vpn_local_ip }} set queue iked
          pass out log on {{ ext_if }} proto esp from {{ vpn_local_ip }} to {{ vpn_remote_ip }} set queue iked
          pass in log on enc0 proto ipencap from {{ vpn_remote_ip }} to {{ vpn_local_ip }} keep state (if-bound) set queue iked
          pass out log on enc0 proto ipencap from {{ vpn_local_ip }} to {{ vpn_remote_ip }} keep state (if-bound) set queue iked
      marker: "# {mark} ANSIBLE MANAGED BLOCK - pf iked config"
      backup: yes
      validate: "/sbin/pfctl -n -f %s"
    register: pf_config_result

  - name: pf - check conf
    shell: pfctl -nf /etc/pf.conf
    register: pf_result

  - name: pf - activate pf
    shell: pfctl -f /etc/pf.conf
    when: pf_result is succeeded

  - name: iked - start
    service: name=iked state=started

  - name: iked - activate iked
    shell: iked -f /etc/pf.conf
    when: pf_result is succeeded and iked_result is changed

  - name: iked - enable
    shell: rcctl enable iked

  #######################################
  # BIRD / BGP
  #######################################
- name: configure bgp / bird
  hosts: bird_hosts
  user: admin
  become: true
  become_method: doas

  tasks:
  - name: bird - check if interface exists
    shell: ifconfig {{ bgp_dev }}
    register: bgp_interface_exists
    ignore_errors: true

  - name: bird - create interface
    shell: ifconfig {{ bgp_dev }} create
    when: bgp_interface_exists|failed

  - name: bird - configure ha ip
    blockinfile:
      dest: /etc/hostname.{{ bgp_dev }}
      block: |
        inet {{ bgp_ha_ip }}/{{ bgp_ha_ip_mask }}
        up
      create: true
      backup: yes
    register: bird_ip_config_results

  - name: bird - restart network if ip config changed
    shell: sh /etc/netstart
    when: bird_ip_config_results|changed

  - name: bird - install
    openbsd_pkg: name=bird state=present
    register: bird_install_results

  - name: bird - delete existing config
    file:
      path: /etc/bird.conf
      state: absent
    when: bird_install_results|changed

  - name: bird - configure
    blockinfile:
      dest: /etc/bird.conf
      block: |
        log "/var/log/bird" all;
        router id {{ node_ip }};
        protocol device
        {
            scan time 5;
        }
        protocol direct
        {
            interface "{{ bgp_dev }}";
        }
        protocol bgp vultr
        {
            export filter {
                bgp_path.prepend({{ bgp_as }});
                accept;
            };
            local as {{ bgp_as }};
            source address {{ node_ip }};
            import none;
            export all;
            graceful restart on;
            next hop self;
            multihop 2;
            neighbor {{ bgp_neigh }} as {{ bgp_neigh_as }};
            password "{{ bgp_pass }}";
        }
      marker: "# {mark} ANSIBLE MANAGED BLOCK - bird config"
      create: true
      backup: yes
      state: present
    register: bird_config_results

  - name: bird - reload bird
    service: name=bird state=reloaded
    when: bird_config_results|changed

  - name: bird - start
    service: name=bird state=started

  - name: bird - enable bird
    shell: rcctl enable bird

  #######################################
  # RELAYD
  #######################################
- name: configure relayd
  hosts: relayd_hosts
  user: admin
  become: true
  become_method: doas

  tasks:
  - name: relayd - start
    service: name=relayd state=started

  - name: relay - enable relayd
    shell: rcctl enable relayd

  - name: relayd - configure
    blockinfile:
      dest: /etc/relayd.conf
      block: |
          table <rrr_hosts> { 37.48.90.117 }
          table <wurstbot_http_hosts> { {{ nagios_clients_http | join(' ') }} }
          table <wurstbot_nagios_hosts> { {{ nagios_servers | join(' ') }} }
          table <wurstbot_mysql_hosts> { {{ nagios_clients_mysql | join(' ') }} }
          table <wurstbot_squid_hosts> { {{ nagios_clients_squid | join(' ') }} }
          table <wurstbot_repo_hosts> { {{ nagios_clients_repo | join(' ') }} }
          table <wurstbot_wiki_hosts> { {{ nagios_clients_wiki | join(' ') }} }
          table <wurstbot_zabbix_hosts> { {{ zabbix_servers | join(' ') }} }

          http protocol "proxy" {
              tcp { nodelay, sack, socket buffer 65536, backlog 100 }
              pass request quick header "Host" value "www.riderunrumble.com" forward to <rrr_hosts>
              pass request quick header "Host" value "www.wurstbot.com" forward to <wurstbot_http_hosts>
              pass request quick header "Host" value "nagios.wurstbot.com" forward to <wurstbot_nagios_hosts>
              pass request quick header "Host" value "mysql.wurstbot.com" forward to <wurstbot_mysql_hosts>
              pass request quick header "Host" value "squid.wurstbot.com" forward to <wurstbot_squid_hosts>
              pass request quick header "Host" value "repo.wurstbot.com" forward to <wurstbot_repo_hosts>
              pass request quick header "Host" value "wiki.wurstbot.com" forward to <wurstbot_wiki_hosts>
              pass request quick header "Host" value "zabbix.wurstbot.com" forward to <wurstbot_zabbix_hosts>
              return error
              pass
          }

          relay "wurstbot_http_relay" {
              listen on {{ bgp_ha_ip }} port 80
              protocol "proxy"
              forward to <rrr_hosts> port 80 check http "/" code 301
              forward to <wurstbot_http_hosts> port 80 check http "/" code 200
              forward to <wurstbot_nagios_hosts> port 80 check http "/" code 200
              forward to <wurstbot_repo_hosts> port 80 check http "/" code 200
              forward to <wurstbot_wiki_hosts> port 80 check http "/" code 200
              forward to <wurstbot_zabbix_hosts> port 80 check http "/" code 200
          }

          relay "wurstbot_mysql_relay" {
              listen on {{ bgp_ha_ip }} port 3306
              protocol "proxy"
              forward to <wurstbot_mysql_hosts> port 3306 check tcp
          }

          relay "wurstbot_squid_relay" {
              listen on {{ bgp_ha_ip }} port 3128
              protocol "proxy"
              forward to <wurstbot_squid_hosts> port 3128 check tcp
          }
      backup: yes
      marker: "# {mark} ANSIBLE MANAGED BLOCK - relayd config"
    register: relayd_config_results

  - name: relayd - check config
    command: /usr/sbin/relayd -nf /etc/relayd.conf
    register: relayd_result
    ignore_errors: yes

  - name: relayd - handle failure
    action: fail msg="relayd.conf check failed."
    when: relayd_result|failed

  - name: relayd - started
    service: name=relayd state=started

  - name: relayd - enable
    shell: rcctl enable relayd

  - name: relayd - reload relayd
    service: name=relayd state=reloaded
    when: relayd_config_results|changed and relayd_result is succeeded

  #######################################
  # SSH
  #######################################
- name: configure ssh
  hosts: all_hosts
  user: admin
  become: true
  become_method: doas

  tasks:
  - name: ssh - start
    service: name=sshd state=started

  - name: ssh - enable ssh
    shell: rcctl enable sshd

  - name: ssh - set authorized key (admin)
    authorized_key:
      user: admin
      state: present
      key: "{{ lookup('file', '~/.ssh/id_ecdsa.pub') }}"

  - name: ssh - set authorized key (ansible)
    authorized_key:
      user: admin
      state: present
      key: "{{ lookup('file', '~/.ssh/id_ansible.pub') }}"

  - name: ssh - configure sshd
    blockinfile:
      dest: /etc/ssh/sshd_config
      block: |
        Port {{ ssh_port }}
        PermitRootLogin no
        PasswordAuthentication no
        UseDNS no
      backup: yes
      marker: "# {mark} ANSIBLE MANAGED BLOCK - ssh config"
      validate: "/usr/sbin/sshd -T -f %s"
    register: ssh_config_results

  - name: ssh - reload sshd
    service: name=sshd state=reloaded
    when: ssh_config_results|changed

  #######################################
  # ACME
  #######################################
- name: configure acme
  hosts: all_hosts
  user: admin
  become: true
  become_method: doas

  tasks:
  - name: acme - configure acme
    blockinfile:
      dest: /etc/acme-client.conf
      block: |
        domain "{{ dns_name }}" {
          alternative names { {{ www_dns_name }} {{ acme_aliases | join(' ') }} }
          domain key "/etc/ssl/private/{{ dns_name }}.key"
          domain certificate "/etc/ssl/{{ dns_name }}.crt"
          domain full chain certificate "/etc/ssl/{{ dns_name }}.fullchain.pem"
          sign with letsencrypt
        }
      backup: yes
      create: true
    when: use_tls==true

    #make sure the cert does not exist yet and a webserver is able to satisify the request
  - name: acme - configure cert and key
    shell: /usr/sbin/acme-client -vD {{ dns_name }}
    when: use_tls == true
    ignore_errors: true

  - name: acme - create ocsp
    shell: ocspcheck -No /etc/ssl/{{ dns_name }}.der /etc/ssl/{{ dns_name }}.fullchain.pem
    register: ocsp_create_result
    when: use_tls == true
    ignore_errors: true

  - name: acme - delete old key and cert if expired
    shell: rm /etc/ssl/private/{{ dns_name }}.key ; rm /etc/ssl/certs/{{ dns_name }}.*
    ignore_errors: true
    register: acme_expired_deletion_result
    when: ocsp_create_result.stdout.find('old') != -1 and use_tls==true

  - name: acme - create new key and cert if expired
    shell: /usr/sbin/acme-client -vAD {{ dns_name }}
    register: acme_renew_result
    when: acme_expired_deletion_result is succeeded and use_tls==true
    ignore_errors: true

  - name: acme - refresh ocsp if key and cert were renewed
    shell: ocspcheck -No /etc/ssl/{{ dns_name }}.der /etc/ssl/{{ dns_name }}.fullchain.pem
    register: ocsp_create_result
    when: acme_renew_result is succeeded and use_tls==true
    ignore_errors: true

  - name: acme - backup certs and keys
    shell: cd /etc/ssl ; tar cfz ~/node{{ node_number }}.wurstbot.com-tls-$(date +%Y%m%d_%H%M%S).tgz private/node{{ node_number }}.wurstbot.com.key node{{ node_number }}.wurstbot.com.*
    register: acme_backup_results
    when: acme_renew_result is succeeded and use_tls==true
    ignore_errors: true

  #######################################
  # NRPE
  #######################################
- name: configure nrpe
  hosts: all_hosts
  user: admin
  become: true
  become_method: doas

  tasks:
  - name: nrpe - install
    openbsd_pkg: name=nrpe-{{ nrpe_version }} state=present

  - name: nrpe - start
    service: name=nrpe state=started

  - name: nrpe - enable
    shell: rcctl enable nrpe

  - name: nrpe - concatenate commands
    set_fact:
      nrpe_commands_list: "{{ nrpe_commands | join('\n') }}"

  - name: nrpe - config service
    blockinfile:
      dest: /etc/nrpe.cfg
      block: |
        log_facility=daemon
        server_port={{ nrpe_port }}
        allowed_hosts={{ nagios_servers| join(', ') }}
        debug=0
        connection_timeout=300
        allow_weak_random_seed=0
        {{ nrpe_commands_list }}
      marker: "# {mark} ANSIBLE MANAGED BLOCK - nrpe config"
      backup: yes
      state: present
    register: nrpe_config_results

  # - name: nrpe - extra config - commands
  #   blockinfile:
  #     dest: /etc/nrpe.cfg
  #     block: |
  #
  #     backup: yes
  #     state: present
  #   register: nrpe_config_results

  - name: nrpe - restart
    service: name=nrpe state=restarted
    when: nrpe_config_results|changed

  #######################################
  # PHP-FPM
  #######################################
- name: configure php-fpm
  hosts: all_hosts
  user: admin
  become: true
  become_method: doas

  tasks:
  - name: php-fpm - install php and modules
    openbsd_pkg: name={{ item }} state=present
    with_items:
        - php-{{ php_version }}
        - php-curl-{{ php_version }}
        - php-mysql-{{ php_version }}
        - php-mysqli-{{ php_version }}
        - php-zip-{{ php_version }}
        - php-gd-{{ php_version }}
        - php-mcrypt-{{ php_version }}
        - php-bz2-{{ php_version }}
        - php-intl-{{ php_version }}

  - name: php-fpm - start
    service: name=php56_fpm state=started

  - name: php-fpm - enable
    shell: rcctl enable php56_fpm

  - name: php-fpm - symlink modules
    file:
      src: '/etc/php-5.6.sample/{{ item }}.ini'
      dest: '/etc/php-5.6/{{ item }}.ini'
      state: link
    with_items:
      - curl
      - mysql
      - zip
      - gd
      - mcrypt
      - bz2
      - intl
    register: phpfpm_results

  - name: php-fpm - configure php-fpm.conf
    lineinfile:
      dest: /etc/php-fpm.conf
      line: listen = 127.0.0.1:{{ php_port }}
      backup: yes
      state: present
    register: phpfpm_results

  - name: php-fpm - configure php.ini
    blockinfile:
      dest: /etc/php-5.6.ini
      block: |
        extension=mysql.so
        extension=mysqli.so
      marker: "# {mark} ANSIBLE MANAGED BLOCK - php.ini config"
      backup: yes
      state: present
    register: phpfpm_results

  - name: php-fpm - restart
    service: name=php56_fpm state=restarted
    when: phpfpm_results|changed

  - name: php-fpm - create test file
    lineinfile:
      dest: /var/www/index.php
      line: <?php phpinfo(); ?>
      state: present
      create: true

  #######################################
  # SLOWCGI
  #######################################
- name: configure slowcgi
  hosts: all_hosts
  user: admin
  become: true
  become_method: doas

  tasks:
  - name: slowcgi - started
    service: name=slowcgi state=started

  - name: slowcgi - enable
    shell: rcctl enable slowcgi


  #######################################
  # HTTPD
  #######################################
- name: configure httpd
  hosts: all_hosts
  user: admin
  become: true
  become_method: doas

  tasks:
  - name: httpd - configure httpd
    blockinfile:
      dest: /etc/httpd.conf
      block: |
        server {{ dns_name }} {
           alias {{ www_dns_name }}
           listen on egress port 80
           listen on lo port 80
           root "/"

           location "/.well-known/acme-challenge/*" {
                root "/acme"
                root strip 2
           }

           location "*.php*" {
              fastcgi socket ":{{ php_port }}"
           }

           location "*.cgi" {
                   root { "/" }
                   fastcgi socket "/run/slowcgi.sock"
           }
        }
      create: true
      marker: "# {mark} ANSIBLE MANAGED BLOCK - default vhost"

  - name: httpd - configure httpd tls
    blockinfile:
      dest: /etc/httpd.conf
      insertafter: "alias www.wurstbot.com"
      block: |
           listen on lo tls port 443
           listen on egress tls port 443
           tls certificate "/etc/ssl/{{ dns_name }}.crt"
           tls key "/etc/ssl/private/{{ dns_name }}.key"
           tls ocsp "/etc/ssl/{{ dns_name }}.der"
           # block return 301 "https://$HTTP_HOST$REQUEST_URI"
           # hsts
      create: true
      marker: "# {mark} ANSIBLE MANAGED BLOCK - default vhost tls"
    when: use_tls==True

  - name: httpd - check config
    command: /usr/sbin/httpd -n
    register: httpd_result
    ignore_errors: yes

  - name: httpd - handle failure
    action: fail msg="httpd.conf check failed."
    when: httpd_result|failed

  - name: httpd - started
    service: name=slowcgi state=started

  - name: httpd - enable
    shell: rcctl enable httpd

  - name: httpd - reload httpd
    service: name=httpd state=reloaded
    when: httpd_result is succeeded

  - name: httpd - create test file
    lineinfile:
      dest: /var/www/index.html
      line: <html><p>{{ dns_name }}</p></html>
      state: present
      create: true

  #######################################
  # REPO
  #######################################
- name: configure repos
  hosts: repo_hosts
  user: admin
  become: true
  become_method: doas

  tasks:
  - name: repo - create repo dirs
    file:
      path: "{{ repo_dir }}/{{ item }}"
      owner: root
      group: daemon
      state: directory
      recurse: yes
    with_items:
      - 6.3/amd64
      - 6.3/packages/amd64
      - snapshots/amd64
    register: repo_create_results

    # rsync -av -f"+ */" -f"- *"

  - name: repo - sync repo folders
    shell: cd {{ repo_dir }} ; rsync -av -r --partial --stats rsync://{{ repo_src }}/{{ item }} .
    with_items:
      - "Changelogs"
      - "doc"
      - "LibreSSL"
      - "OpenBGPD"
      - "OpenNTPD"
      - "OpenSSH"
      - "patches"
      - "songs"
      - "syspatch"
      - "tools"
      # - "6.3/packages/amd64/" # packages is too big

  - name: repo - sync repo sub folders
    shell: cd {{ repo_dir }} ; rsync -av -r --partial --stats rsync://{{ repo_src }}/{{ item }} {{ item }}
    with_items:
      - "snapshots/amd64/"
      - "6.3/ANNOUNCEMENT"
      - "6.3/SHA256"
      - "6.3/SHA256.sig"
      - "6.3/ports.tar.gz"
      - "6.3/src.tar.gz"
      - "6.3/sys.tar.gz"
      - "6.3/xenocara.tar.gz"
      - "6.3/amd64/"
      # - "6.3/packages/amd64/" # packages is too big

  - name: repo - configure httpd
    blockinfile:
      dest: /etc/httpd.conf
      block: |
        types {
                include "/usr/share/misc/mime.types"
                text/plain sig
        }

        default type text/plain

        server {{ repo_dns_name }} {
           alias repo{{ node_number }}.wurstbot.com
           listen on egress port 80
           listen on lo port 80
           root "/repo"

           directory auto index

           location "/cgi-bin/man.cgi*" {
              block return 301 "https://man.openbsd.org$REQUEST_URI"
           }

           location "/cgi-bin/cvsweb*" {
              block return 301 "https://cvsweb.openbsd.org$REQUEST_URI"
           }

          location "/.well-known/acme-challenge/*" {
             root "/acme"
             root strip 2
          }
        }
      create: true
      marker: "# {mark} ANSIBLE MANAGED BLOCK - repo vhost"

  - name: httpd - configure httpd tls
    blockinfile:
      dest: /etc/httpd.conf
      insertafter: "alias repo"
      block: |
           listen on lo tls port 443
           listen on egress tls port 443
           tls certificate "/etc/ssl/{{ dns_name }}.crt"
           tls key "/etc/ssl/private/{{ dns_name }}.key"
           tls ocsp "/etc/ssl/{{ dns_name }}.der"
           # block return 301 "https://$HTTP_HOST$REQUEST_URI"
           # hsts
      create: true
      marker: "# {mark} ANSIBLE MANAGED BLOCK - repo vhost tls"
    when: use_tls==True

  - name: httpd - check config
    command: /usr/sbin/httpd -n
    register: httpd_result
    ignore_errors: yes

  - name: httpd - handle failure
    action: fail msg="httpd.conf check failed."
    when: httpd_result|failed

  - name: httpd - started
    service: name=slowcgi state=started

  - name: httpd - enable
    shell: rcctl enable httpd

  - name: httpd - reload httpd
    service: name=httpd state=reloaded
    when: httpd_result is succeeded

  #######################################
  # DOKUWIKI
  #######################################
- name: configure dokuwiki
  hosts: wiki_hosts
  user: admin
  become: true
  become_method: doas

  tasks:
  - name: dokuwiki - install
    openbsd_pkg: name=dokuwiki-{{ dokuwiki_version }} state=present

  - name: dokuwiki - configure httpd vhost
    blockinfile:
      dest: /etc/httpd.conf
      block: |
        server {{ dokuwiki_dns_name }} {
           alias wiki{{ node_number }}.wurstbot.com
           listen on egress port 80
           listen on lo port 80
           root "/dokuwiki"

            directory {
                    index "index.php"
            }

            location "/data" { block }
            location "/conf" { block }
            location "/bin"  { block }
            location "/inc"  { block }
            location "/.ht*" { block }

            location "*.php*" {
                    fastcgi socket ":{{ php_port }}"
            }

            location "/.well-known/acme-challenge/*" {
                root "/acme"
                root strip 2
            }
        }
      create: false
      marker: "# {mark} ANSIBLE MANAGED BLOCK - dokuwiki vhost"
    register: dokuwiki_web_config_results

  - name: httpd - configure httpd tls
    blockinfile:
      dest: /etc/httpd.conf
      insertafter: "alias {{ dokuwiki_dns_name }}"
      block: |
           listen on lo tls port 443
           listen on egress tls port 443
           tls certificate "/etc/ssl/{{ dns_name }}.crt"
           tls key "/etc/ssl/private/{{ dns_name }}.key"
           tls ocsp "/etc/ssl/{{ dns_name }}.der"
           # block return 301 "https://$HTTP_HOST$REQUEST_URI"
           # hsts
      create: true
      marker: "# {mark} ANSIBLE MANAGED BLOCK - dokuwiki vhost tls"
    when: use_tls==True

  - name: dokuwiki - check httpd config
    command: /usr/sbin/httpd -n
    register: httpd_result
    ignore_errors: yes
    when: dokuwiki_web_config_results|changed

  - name: dokuwiki - handle httpd failure
    action: fail msg="httpd.conf check failed."
    when: httpd_result|failed

  - name: dokuwiki - reload httpd when config changed
    service: name=httpd state=reloaded

  #######################################
  # OWNCLOUD
  #######################################
- name: configure owncloud
  hosts: owncloud_hosts
  user: admin
  become: true
  become_method: doas

  tasks:
  - name: owncloud - install
    openbsd_pkg: name={{ item }} state=present
    with_items:
      - owncloud-{{ owncloud_version }}
      - owncloudclient-{{ owncloud_client_version }}

  - name: owncloud - make chrooted php directory
    file:
      path: /var/www/etc/php-5.6
      state: directory

  - name: owncloud - copy php extensions to chrooted php directory
    shell: cp /etc/php-5.6.sample/* /var/www/etc/php-5.6/

  - name: owncloud - copy php.ini to chrooted directory
    copy:
      src: /etc/php-5.6.ini
      dest: /var/www/etc/php-5.6.ini
      remote_src: yes

  - name: owncloud - configure httpd vhost
    blockinfile:
      dest: /etc/httpd.conf
      block: |
        server {{ owncloud_dns_name }} {
           alias owncloud{{ node_number }}.wurstbot.com
           listen on egress port 80
           listen on lo port 80
           root "/owncloud"

           # listen on lo port 443
           # listen on egress tls port 443
           # tls certificate "/etc/ssl/{{ dns_name }}.crt"
           # tls key "/etc/ssl/private/{{ dns_name }}.key"
           # tls ocsp "/etc/ssl/{{ dns_name }}.der"

           # block return 301 "https://$HTTP_HOST$REQUEST_URI"
           # hsts

           directory index "index.php"
           connection max request body {{ owncloud_max_upload }}

            location "/db_structure.xml" { block }
            location "/.ht*"             { block }
            location "/README"           { block }
            location "/data*"            { block }
            location "/config*"          { block }

            location "*.php*" {
                    fastcgi socket ":{{ php_port }}"
            }

            location "/.well-known/acme-challenge/*" {
                root "/acme"
                root strip 2
            }
        }
      create: false
      marker: "# {mark} ANSIBLE MANAGED BLOCK - owncloud vhost"
    register: owncloud_web_config_results

  - name: httpd - configure httpd tls
    blockinfile:
      dest: /etc/httpd.conf
      insertafter: "alias {{ owncloud_dns_name }}"
      block: |
           listen on lo tls port 443
           listen on egress tls port 443
           tls certificate "/etc/ssl/{{ dns_name }}.crt"
           tls key "/etc/ssl/private/{{ dns_name }}.key"
           tls ocsp "/etc/ssl/{{ dns_name }}.der"
           # block return 301 "https://$HTTP_HOST$REQUEST_URI"
           # hsts
      create: true
      marker: "# {mark} ANSIBLE MANAGED BLOCK - owncloud vhost tls"
    when: use_tls==True

  - name: owncloud - check httpd config
    command: /usr/sbin/httpd -n
    register: httpd_result
    ignore_errors: yes
    when: owncloud_web_config_results|changed

  - name: owncloud - handle httpd failure
    action: fail msg="httpd.conf check failed."
    when: httpd_result|failed

  - name: owncloud - reload httpd when config changed
    service: name=httpd state=reloaded
    when: owncloud_web_config_results|changed and httpd_result is succeeded

  #######################################
  # SQUID
  #######################################
- name: configure squid
  hosts: squid_hosts
  user: admin
  become: true
  become_method: doas

  tasks:
  - name: squid - install
    openbsd_pkg: name=squid state=present

  - name: squid - start
    service: name=squid state=started

  - name: squid - enable
    shell: rcctl enable squid

  - name: squid - create log dir
    file:
      path: /var/squid/logs
      owner: _squid
      group: _squid
      state: directory

  - name: squid - create cache log
    file:
      path: /var/squid/logs/cache.log
      owner: _squid
      group: _squid
      state: touch
    register: squid_cache_log_results

  - name: squid - create access log
    file:
      path: /var/squid/logs/access.log
      owner: _squid
      group: _squid
      state: touch
    register: squid_access_log_results

  - name: squid - delete existing config
    file:
      path: /etc/squid/squid.conf
      state: absent

  - name: squid - config service
    blockinfile:
      dest: /etc/squid/squid.conf
      block: |
          client_db on
          httpd_suppress_version_string on
          ignore_unknown_nameservers on
          retry_on_error on
          access_log /var/squid/logs/access.log
          cache_log /var/squid/logs/cache.log

          acl home src 31.201.195.130
          acl work src 84.207.225.37

          acl SSL_ports port 443
          acl Safe_ports port 80          # http
          acl Safe_ports port 443         # https
          acl Safe_ports port 1025-65535  # unregistered ports
          acl CONNECT method CONNECT

          http_access deny !Safe_ports
          http_access deny CONNECT !SSL_ports
          http_access allow localhost manager
          http_access deny manager

          http_access allow localhost
          http_access allow home
          http_access allow work
          http_access deny all

          http_port 3128
          coredump_dir /var/squid/cache
          cache_mem {{ squid_cache_mem }} MB
          minimum_object_size 10 KB
          maximum_object_size 8 MB
      state: present
      create: true
      backup: yes
      marker: "# {mark} ANSIBLE MANAGED BLOCK - squid config"
    when: squid_cache_log_results is succeeded and squid_access_log_results is succeeded
    register: squid_config_results

  - name: squid - check config
    command: squid -k parse
    register: squid_result
    ignore_errors: yes

  - name: squid - handle failure
    action: fail msg="squid.conf check failed."
    when: squid_result|failed

  - name: squid - restart
    service: name=squid state=restarted
    when: squid_result is succeeded and squid_config_results|changed

  - name: squid - enable
    shell: rcctl enable squid

  #######################################
  # SMTPD
  #######################################
- name: configure smtpd
  hosts: mail_hosts
  user: admin
  become: true
  become_method: doas

  tasks:
  # - name: smtpd - config aliases
  #   blockinfile:
  #     dest: /etc/mail/domains
  #     block: |
  #         // aliases go here
  #     state: present
  #     create: true
  #     backup: yes
  #   register: smtpd_aliases_results

  - name: smtpd - config domains
    blockinfile:
      dest: /etc/mail/domains
      block: |
          wurstbot.com
      state: present
      create: true
      backup: yes
    register: smtpd_domains_results

  - name: smtpd - config virtuals
    blockinfile:
      dest: /etc/mail/virtuals
      block: |
          zabbix@wurstbot.com     root
          nagios@wurstbot.com     root
          admin@wurstbot.com      root
      state: present
      create: true
      backup: yes
    register: smtpd_virtuals_results

  - name: smtpd - config credentials
    shell: pass=$(echo {{ smtpd_pass }} | smtpctl encrypt) ; echo {{ admin_user }}:$pass > /etc/mail/creds
    register: smtpd_creds_results

  - name: smtpd - delete existing config
    file:
      path: /etc/mail/smtpd.conf
      state: absent

  - name: smtpd - config service
    blockinfile:
      dest: /etc/mail/smtpd.conf
      block: |
          table aliases file:/etc/mail/aliases
          table domains file:/etc/mail/domains
          table creds file:/etc/mail/creds

          pki node{{ node_number}} certificate  "/etc/ssl/{{ dns_name }}.crt"
          pki node{{ node_number}} key          "/etc/ssl/private/{{ dns_name }}.key"

          # Accept external mail
          listen on all port 25 tls pki node{{node_number}} auth-optional <creds>
          listen on all port 587 tls-require pki node{{node_number}} auth-optional <creds>
          listen on all port 465 smtps pki node{{node_number}} auth-optional <creds>

          # Accept external mail for domain "wurstbot.com"
          accept from any for domain <domains> alias <aliases> deliver to mbox
          accept for local alias <aliases> deliver to mbox
          accept from local for any relay
      state: present
      create: true
      backup: yes
    # when: smtpd_aliases_results is succeeded and smtpd_domains_results is succeeded and smtpd_virtuals_results is succeeded and smtpd_creds_results is succeeded
    register: smtpd_config_results

  - name: smtpd - restarted
    service: name=smtpd state=restarted
    when: smtpd_config_results|changed

  - name: smtpd - start
    service: name=smtpd state=started

  - name: smtpd - enable
    shell: rcctl enable smtpd

  #######################################
  # DOVECOT
  #######################################
- name: configure dovecot
  hosts: mail_hosts
  user: admin
  become: true
  become_method: doas

  tasks:
  - name: dovecot - install
    openbsd_pkg: name=dovecot state=present

  - name: dovecot - raise file limit
    blockinfile:
      dest: /etc/login.conf
      block: |
        dovecot:\
          :openfiles=2048:\
          :tc=daemon:
      state: present
      create: true
      backup: yes

  - name: dovecot - config mail location
    blockinfile:
      dest: /etc/dovecot/conf.d/10-mail.conf
      block: |
          mail_location = mbox:~/mail:INBOX=/var/mail/%u
      state: present
      create: true
      backup: yes
    register: dovecot_config_mail_results

    # required to be removed (duplicate )
    # ssl_cert = </etc/ssl/dovecotcert.pem
    # ssl_key = </etc/ssl/private/dovecot.pem
  - name: dovecot - config ssl
    blockinfile:
      dest: /etc/dovecot/conf.d/10-ssl.conf
      block: |
          ssl_cert = </etc/ssl/{{ dns_name }}.crt
          ssl_key = </etc/ssl/private/{{ dns_name }}.key
          ssl_dh_parameters_length = 4096
          ssl_protocols = !SSLv3 !SSLv2
          ssl_cipher_list = AES128+EECDH:AES128+EDH
          ssl_prefer_server_ciphers = yes
      state: present
      create: true
      backup: yes
      # validate: "dovecot -n -f %s"
    register: dovecot_config_ssl_results

  - name: dovecot - check config
    shell: dovecot -n
    register: dovecot_config_check
    ignore_errors: true

  - name: dovecot - restarted
    service: name=dovecot state=restarted
    when: dovecot_config_check is succeeded

  - name: dovecot - enable
    shell: rcctl enable dovecot

  - name: dovecot - configure httpd
    blockinfile:
      dest: /etc/httpd.conf
      block: |
        server {{ mail_dns_name }} {
           alias mail{{ node_number }}.wurstbot.com

           listen on egress port 80
           listen on lo port 80
           root "/"

           location "/.well-known/acme-challenge/*" {
                root "/acme"
                root strip 2
           }
        }
      create: true
      marker: "# {mark} ANSIBLE MANAGED BLOCK - mail vhost"

  - name: httpd - configure httpd tls
    blockinfile:
      dest: /etc/httpd.conf
      insertafter: "alias mail"
      block: |
           listen on lo tls port 443
           listen on egress tls port 443
           tls certificate "/etc/ssl/{{ dns_name }}.crt"
           tls key "/etc/ssl/private/{{ dns_name }}.key"
           tls ocsp "/etc/ssl/{{ dns_name }}.der"
           # block return 301 "https://$HTTP_HOST$REQUEST_URI"
           # hsts
      create: true
      marker: "# {mark} ANSIBLE MANAGED BLOCK - dovecot vhost tls"
    when: use_tls==True

  - name: dovecot - check config
    command: /usr/sbin/httpd -n
    register: httpd_result
    ignore_errors: yes

  - name: dovecot - handle failure
    action: fail msg="httpd.conf check failed."
    when: httpd_result|failed

  - name: dovecot - started
    service: name=slowcgi state=started

  - name: dovecot - enable
    shell: rcctl enable httpd

  - name: dovecot - reload httpd
    service: name=httpd state=reloaded
    when: httpd_result is succeeded


  #######################################
  # SPAMD
  #######################################
- name: configure spamd
  hosts: mail_hosts
  user: admin
  become: true
  become_method: doas

  tasks:
  - name: spamd - enable
    shell: rcctl enable spamd

  - name: spamd - config service
    blockinfile:
      dest: /etc/rc.conf.local
      block: |
          spamd_black=NO
          spamd_flags="-4 -C /etc/ssl/{{ dns_name }}.crt -G25:4:864 -h mail.wurstbot.com -n \"Sendmail 8.11.4/8.11.1\" -v -w1"
          spamlogd_flags="-I -i lo0"
      state: present
      create: true
      backup: yes
      marker: "# {mark} ANSIBLE MANAGED BLOCK - spamd config"
    register: spamd_config_results

  - name: spamd - config nospamd
    blockinfile:
      dest: /etc/mail/nospamd
      block: |
          127.0.0.1
          46.36.36.48
          80.240.28.59
          45.32.185.50
          45.32.152.181
          209.250.244.111
      state: present
      create: true
      backup: yes
    register: spamd_nospamd_results

  - name: spamd - configure packet filter
    blockinfile:
      dest: /etc/pf.conf
      block: |
          table <spamd-white> persist
          table <nospamd> persist file "/etc/mail/nospamd"
          pass in on egress proto tcp from any to any port smtp rdr-to 127.0.0.1 port spamd
          pass in on egress proto tcp from <nospamd> to any port smtp
          pass in log on egress proto tcp from <spamd-white> to any port smtp
          pass out log on egress proto tcp to any port smtp
      backup: yes
      marker: "# {mark} ANSIBLE MANAGED BLOCK - spamd pf config"
      validate: "/sbin/pfctl -n -f %s"

    #sometimes spamd acts like as if its broken
  - name: spamd - start
    service: name=spamd state=started
    ignore_errors: true

    #error handling required, e. g. grep for runnings processes

  - name: spamd - enable
    shell: rcctl enable spamd

  - name: spamlogd - start
    service: name=spamlogd state=started

  - name: spamlogd - enable
    shell: rcctl enable spamlogd

  #######################################
  # ZABBIX AGENT
  #######################################
- name: configure zabbix agent
  hosts: all_hosts
  user: admin
  become: true
  become_method: doas

  tasks:
  - name: zabbix agent - install
    openbsd_pkg: name={{ item }} state=present
    with_items:
      - zabbix-agent-{{ zabbix_version }}

  # configure zabbix prerequisites
  - name: zabbix - create log dir
    file:
      path: /var/log/zabbix/
      owner: _zabbix
      group: _zabbix
      state: directory

  # configure zabbix prerequisites
  - name: zabbix - create scripts dir
    file:
      path: /etc/zabbix/externalscripts
      owner: _zabbix
      group: _zabbix
      state: directory

  - name: zabbix - create log files
    file:
      path: /var/log/zabbix/{{ item }}.log
      owner: _zabbix
      group: _zabbix
      state: touch
    with_items:
      - zabbix_server
      - zabbix_proxy
      - zabbix_agentd
    register: zabbix_log_results

  - name: zabbix - create pid files
    file:
      path: /var/run/{{ item }}.pid
      owner: _zabbix
      group: _zabbix
      state: touch
    with_items:
      - zabbix_server
      - zabbix_proxy
      - zabbix_agentd
    register: zabbix_pid_results

  - name: zabbix agent - config zabbix agent
    blockinfile:
      dest: /etc/zabbix/zabbix_agentd.conf
      block: |
          PidFile=/var/run/zabbix_agentd.pid
          LogType=file
          LogFile=/var/log/zabbix/zabbix_agentd.log
          LogFileSize=10
          EnableRemoteCommands=1
          LogRemoteCommands=1
          Server={{ zabbix_servers |join(', ') }}
          ServerActive={{ zabbix_servers |join(', ') }}
          ListenPort=10050
          Hostname={{ dns_name }}
          ListenIP=0.0.0.0
          Include=/etc/zabbix/userparameters.conf
      state: present
      marker: "# {mark} ANSIBLE MANAGED BLOCK - zabbix agent config"
      create: true
      backup: yes
    when: zabbix_log_results is succeeded and zabbix_pid_results is succeeded
    register: zabbix_agent_config_results

  - name: zabbix agent - config user parameters
    blockinfile:
      dest: /etc/zabbix/userparameters.conf
      block: |
          # mysql
          UserParameter=mysql.status[*],echo "show global status where Variable_name='$1';" | HOME=/var/lib/mysql/DBNAME mysql -N | awk '{print $$2}'
          UserParameter=mysql.version,mysql -V
          UserParameter=mysql.ping,mysqladmin -u {{ zabbix_db_user }} --password={{ zabbix_db_pass }} ping | grep alive | wc -l | tr -d " "
          UserParameter=mysql.uptime,mysqladmin -u {{ zabbix_db_user }} --password={{ zabbix_db_pass }} status | cut -f2 -d ":" | cut -f1 -d "T" | tr -d " "
          UserParameter=mysql.threads,mysqladmin -u {{ zabbix_db_user }} --password={{ zabbix_db_pass }} status | cut -f3 -d ":" | cut -f1 -d "Q" | tr -d " "
          UserParameter=mysql.questions,mysqladmin -u {{ zabbix_db_user }} --password={{ zabbix_db_pass }} status | cut -f4 -d ":"|cut -f1 -d "S" | tr -d " "
          UserParameter=mysql.slowqueries,mysqladmin -u {{ zabbix_db_user }} --password={{ zabbix_db_pass }} status | cut -f5 -d ":" | cut -f1 -d "O" | tr -d " "
          UserParameter=mysql.qps,mysqladmin -u {{ zabbix_db_user }} --password={{ zabbix_db_pass }} status | cut -f9 -d ":" | tr -d " "
      state: present
      marker: "# {mark} ANSIBLE MANAGED BLOCK - zabbix agent userparams config"
      create: true
      backup: yes
    register: zabbix_agent_userparams_results

  - name: zabbix agent - config agent mysql parameters
    blockinfile:
      dest: /etc/my.cnf
      block: |
            [client]
            user            = {{ zabbix_db_user }}
            password        = {{ zabbix_db_pass }}
            port            = 3306
      state: present
      marker: "# {mark} ANSIBLE MANAGED BLOCK - zabbix agent mysql config"
      create: true
      backup: yes

  - name: zabbix agent - started
    service: name=zabbix_agentd state=started

  - name: zabbix agent - enable
    shell: rcctl enable zabbix_agentd

  #######################################
  # ZABBIX SERVER
  #######################################
- name: configure zabbix server
  hosts: zabbix_server_hosts
  user: admin
  become: true
  become_method: doas

  tasks:
  - name: zabbix server - install
    openbsd_pkg: name={{ item }} state=present
    with_items:
      - zabbix-server-{{ zabbix_version}}-mysql
      - zabbix-web

  - name: zabbix - configure php.ini
    blockinfile:
      dest: /etc/php-5.6.ini
      block: |
          max_execution_time 300
          memory_limit 128M
          post_max_size 16M
          upload_max_filesize 2M
          max_input_time 300
          always_populate_raw_post_data -1
      backup: yes
      state: present
      marker: "# {mark} ANSIBLE MANAGED BLOCK - zabbix php options"
    register: zabbix_php_results

  - name: zabbix - create db
    mysql_db:
      name: zabbix
      encoding: utf8
      collation: utf8_bin
      login_user: root
      login_password: "{{ mysql_root_pass }}"
      state: present
    register: zabbix_create_db_results
    when: zabbix_install_mode == True

  - name: zabbix - grant permissions to zabbix user
    mysql_user: name='{{ zabbix_db_user }}' password={{ zabbix_db_pass }} priv="zabbix.*:ALL" login_user=root login_password="{{ mysql_root_pass }}" host={{ node_ip }} state=present

  - name: zabbix - download source package for db dumps
    get_url:
      url: https://sourceforge.net/projects/zabbix/files/ZABBIX%20Latest%20Stable/{{ zabbix_version }}/zabbix-{{ zabbix_version }}.tar.gz/download
      dest: /tmp/zabbix-{{ zabbix_version }}.tar.gz
      mode: 0440
    when: zabbix_install_mode == True

  - name: zabbix - make source directory
    file:
      path: /tmp/zabbix-{{ zabbix_version }}
      state: directory
    when: zabbix_install_mode == True

  # - name: zabbix - unpack source package
  #   unarchive:
  #     src: /tmp/zabbix-{{ zabbix_version }}.tar.gz
  #     dest: /tmp/zabbix-{{ zabbix_version }}
  #     remote_src: yes
  #   when: zabbix_install_mode == True

  - name: zabbix - unpack source package
    shell: tar xfz /tmp/zabbix-{{ zabbix_version }}.tar.gz -C /tmp/
    when: zabbix_install_mode == True and zabbix_create_db_results|changed

  - name: zabbix - import databases
    mysql_db:
      name: zabbix
      login_user: root
      login_password: "{{ mysql_root_pass }}"
      target: /tmp/zabbix-{{ zabbix_version }}/database/mysql/{{ item }}.sql
      state: import
    with_items:
      - schema
      - images
      - data
    when: zabbix_install_mode == True and zabbix_create_db_results|changed
    ignore_errors: true

  - name: zabbix - config zabbix server
    blockinfile:
      dest: /etc/zabbix/zabbix_server.conf
      block: |
          PidFile=/var/run/zabbix_server.pid
          LogType=file
          LogFile=/var/log/zabbix/zabbix_server.log
          DBHost={{ node_ip }}
          DBName=zabbix
          DBUser={{ zabbix_db_user }}
          DBPassword={{ zabbix_db_pass }}
          # DBSocket=/tmp/mysql.sock
          DBPort=3306
          ExternalScripts=/etc/zabbix/externalscripts
      state: present
      marker: "# {mark} ANSIBLE MANAGED BLOCK - zabbix server config"
      create: true
      backup: yes
    when: zabbix_log_results is succeeded and zabbix_pid_results is succeeded
    register: zabbix_server_config_results

  - name: zabbix - started
    service: name=zabbix_server state=started

  - name: zabbix - enable
    shell: rcctl enable zabbix_server

  - name: zabbix - make chrooted php directory
    file:
      path: /var/www/etc/php-5.6
      state: directory
    when: zabbix_install_mode == True

  - name: zabbix - copy php extensions to chrooted php directory
    shell: cp /etc/php-5.6.sample/* /var/www/etc/php-5.6/
    when: zabbix_install_mode == True

  - name: zabbix - copy php.ini to chrooted directory
    copy:
      src: /etc/php-5.6.ini
      dest: /var/www/etc/php-5.6.ini
      remote_src: yes
    when: zabbix_install_mode == True

  # Use 127.0.0.1 over localhost to avoid issues
  - name: zabbix - configure web interface
    blockinfile:
      dest: /var/www/zabbix/conf/zabbix.conf.php
      block: |
          $DB['TYPE']       = 'MYSQL';
          $DB['SERVER']     = '{{ node_ip }}';
          $DB['PORT']       = '3306';
          $DB['DATABASE']   = 'zabbix';
          $DB['USER']       = '{{ zabbix_db_user }}';
          $DB['PASSWORD']   = '{{ zabbix_db_pass }}';
          $ZBX_SERVER       = '{{ node_ip }}';
          $ZBX_SERVER_PORT  = '10051';
          $ZBX_SERVER_NAME  = '{{ dns_name }}';
      backup: yes
      state: present
      marker: "# {mark} ANSIBLE MANAGED BLOCK - zabbix web config"
    register: zabbix_web_config_results
    when: zabbix_install_mode == True

  - name: zabbix - configure httpd vhost
    blockinfile:
      dest: /etc/httpd.conf
      block: |
        server {{ zabbix_dns_name }} {
           alias zabbix{{ node_number }}.wurstbot.com
           listen on egress port 80
           listen on lo port 80
           root "/zabbix"

           # listen on lo port 443
           # listen on egress tls port 443
           # tls certificate "/etc/ssl/{{ dns_name }}.crt"
           # tls key "/etc/ssl/private/{{ dns_name }}.key"
           # tls ocsp "/etc/ssl/{{ dns_name }}.der"

           # block return 301 "https://$HTTP_HOST$REQUEST_URI"
           # hsts

            directory {
                    index "index.php"
            }

            location "*.php*" {
                    fastcgi socket ":{{ php_port }}"
            }

            location "/.well-known/acme-challenge/*" {
                root "/acme"
                root strip 2
            }
        }
      create: false
      marker: "# {mark} ANSIBLE MANAGED BLOCK - zabbix vhost"

  - name: zabbix - check httpd config
    command: /usr/sbin/httpd -n
    register: httpd_result
    ignore_errors: yes
    when: zabbix_web_config_results|changed

  - name: zabbix - handle httpd failure
    action: fail msg="httpd.conf check failed."
    when: httpd_result|failed

  - name: zabbix - reload httpd when config changed
    service: name=httpd state=reloaded
    when: httpd_result is succeeded

  #######################################
  # NAGIOS
  #######################################
- name: configure nagios
  hosts: nagios_server_hosts
  user: admin
  become: true
  become_method: doas

  tasks:
  - name: nagios - install
    openbsd_pkg: name={{ item }} state=present
    with_items:
      - nagios-{{ nagios_version }}-chroot
      # web  is not tested with -chroot yet
      - nagios-web-{{ nagios_web_version }}-chroot
      - py-passlib-1.7.1p0

  - name: nagios - started
    service: name=nagios state=started

  - name: nagios - enable
    shell: rcctl enable nagios

  - name: nagios - configure basic auth for admin
    shell: echo nagiosadmin:{{ nagios_password }} | htpasswd -I /var/www/.nagioshtaccess
    ignore_errors: true
    no_log: true

  - name: nagios - configure basic auth for contacts
    shell: echo {{ item.key }}:{{ item.value.nagios_guest_password }} | htpasswd -I /var/www/.nagioshtaccess
    ignore_errors: true
    no_log: true
    with_dict: "{{ nagios_guests }}"

  - name: nagios - configure contacts
    blockinfile:
      dest: /etc/nagios/objects/contacts.cfg
      block: |
          define contactgroup {
              contactgroup_name       group_{{ item.key }}
              members                 {{ item.key }}
          }
          define contact{
              contact_name                    {{ item.key }}
              alias                           {{ item.key }}
              service_notification_period     24x7
              host_notification_period        24x7
              service_notification_options    w,u,c,r
              host_notification_options       d,r
              service_notification_commands   notify-service-by-email
              host_notification_commands      notify-host-by-email
              email                           {{ item.value.nagios_guest_email }}
          }
      create: true
      backup: yes
      marker: "# {mark} ANSIBLE MANAGED BLOCK - nagios contact {{ item.key }}"
    no_log: true
    with_dict: "{{ nagios_guests }}"

  - name: nagios - configure commands
    blockinfile:
      dest: /etc/nagios/objects/commands.cfg
      block: |
        define command {
            command_name    check_nrpe
            command_line    $USER1$/check_nrpe -H $HOSTADDRESS$ -c $ARG1$
        }

        define command{
                command_name    check_imaps
                command_line    $USER1$/check_imap -p 993 -S -H $HOSTADDRESS$ $ARG1$
                }

        define command{
                command_name    check_smtps
                command_line    $USER1$/check_smtp -p 587 -S -H $HOSTADDRESS$ $ARG1$
                }

        define command{
                command_name    check_ssmtp
                command_line    $USER1$/check_ssmtp -p 465 -H $HOSTADDRESS$ $ARG1$
                }

        define command{
                command_name    check_cpu
                command_line    $USER1$/check_cpu -H $HOSTADDRESS$ -w $ARG1$ -c $ARG2$ -p $USER3$
        }

        define command{
                command_name    check_swap
                command_line    $USER1$/check_swap -H $HOSTADDRESS$ -w $ARG1$ -c $ARG2$ -p $USER3$
        }

        define command{
                command_name    check_ram
                command_line    $USER1$/check_ram -H $HOSTADDRESS$ -w $ARG1$ -c $ARG2$ -p $USER3$ -o $ARG3$
        }

        define command{
              command_name      check_load
              command_line      $USER1$/check_load -H $HOSTADDRESS$ -w $ARG1$ -c $ARG2$ -p $USER3$
        }
        define command{
              command_name      check_https_url
              command_line      $USER1$/check_http --ssl 1.2+ -H '$HOSTADDRESS$'
        }
        define command{
              command_name      check_https_cert_expiry
              command_line      $USER1$/check_http --ssl 1.2+ -H '$HOSTADDRESS$' -u '$ARG1$' -C 30
        }

      create: true
      backup: yes
      marker: "# {mark} ANSIBLE MANAGED BLOCK - nagios commands"

  - name: nagios - configure hosts
    blockinfile:
      dest: /etc/nagios/objects/localhost.cfg
      block: |
        define host {
                use openbsd-server
                host_name       {{ item }}
                address         {{ item }}.wurstbot.com
        }
      create: true
      backup: yes
      marker: "# {mark} ANSIBLE MANAGED BLOCK - nagios host {{ item }}"
    with_items: '{{ nagios_clients }}'

  - name: nagios - configure guests hosts
    blockinfile:
      dest: /etc/nagios/objects/localhost.cfg
      block: |
        define host {
                use                 openbsd-server
                contact_groups      group_{{ item.key }}
                host_name           {{ item.value.nagios_guest_host }}
                address             {{ item.value.nagios_guest_ip }}
                notifications_enabled           0
        }
      create: true
      backup: yes
      marker: "# {mark} ANSIBLE MANAGED BLOCK - nagios guest {{ item.key }} host"
    no_log: true
    with_dict: '{{ nagios_guests }}'

  - name: nagios - configure hostgroups
    blockinfile:
      dest: /etc/nagios/objects/localhost.cfg
      block: |
        define hostgroup {
                hostgroup_name  wurstbot-openbsd-servers ;
                alias           OpenBSD Servers ;
                members         {{ nagios_clients |join(', ') }}
        }
      marker: "# {mark} ANSIBLE MANAGED BLOCK - nagios hostgroups "
      create: true
      backup: yes
    with_items: '{{ nagios_clients }}'

  - name: nagios - configure services
    blockinfile:
      dest: /etc/nagios/objects/localhost.cfg
      block: |
        # LOAD CHECKS
        ############
        define service{
                use                             local-service
                host_name                       {{ nagios_clients |join(', ') }}
                service_description             Users check
                check_command                   check_nrpe!check_users
                notifications_enabled           0
        }
        define service{
                use                             local-service
                host_name                       {{ nagios_clients |join(', ') }}
                service_description             Load check
                check_command                   check_nrpe!check_load
                notifications_enabled           0
        }
        define service{
                use                             local-service
                host_name                       {{ nagios_clients |join(', ') }}
                service_description             Disk check
                check_command                   check_nrpe!check_disk
                notifications_enabled           0
        }
        define service{
                use                             local-service
                host_name                       {{ nagios_clients |join(', ') }}
                service_description             Zombie procs check
                check_command                   check_nrpe!check_zombie_procs
                notifications_enabled           0
        }
        define service{
                use                             local-service
                host_name                       {{ nagios_clients |join(', ') }}
                service_description             Total procs check
                check_command                   check_nrpe!check_total_procs
                notifications_enabled           0
        }

        define service{
                use                             local-service
                host_name                       {{ nagios_clients |join(', ') }}
                service_description             PING
                check_command                   check_ping!100.0,20%!500.0,60%
                notifications_enabled           0
        }
        # TCP CHECKS
        ############
        define service{
                use                             local-service
                host_name                       {{ nagios_clients_bgp |join(', ') }}
                service_description             BGP
                check_command                   check_tcp!179
                notifications_enabled           0
        }
        define service{
                use                             local-service
                host_name                       {{ nagios_clients_ssh |join(', ') }}
                service_description             SSH
                check_command                   check_tcp!{{ ssh_port }}
                notifications_enabled           0
        }
        define service{
                use                             local-service
                host_name                       {{ nagios_clients_squid |join(', ') }}
                service_description             squid
                check_command                   check_tcp!3128
                notifications_enabled           0
        }
        define service{
                use                             local-service
                host_name                       {{ nagios_clients_mysql |join(', ') }}
                service_description             mysql
                check_command                   check_tcp!3306
                notifications_enabled           0
        }
        define service{
                use                             local-service
                host_name                       {{ zabbix_clients |join(', ') }}
                service_description             zabbix agent
                check_command                   check_tcp!10050
                notifications_enabled           0
        }
        define service{
                use                             local-service
                host_name                       {{ zabbix_servers |join(', ') }}
                service_description             zabbix server
                check_command                   check_tcp!10051
                notifications_enabled           0
        }
        # define service{
        #         use                             local-service
        #         host_name                       __nagios_clients_tor |join(', ') }}
        #         service_description             Tor SocksPort
        #         check_command                   check_tcp!9050
        #         notifications_enabled           1
        # }
        # define service{
        #         use                             local-service
        #         host_name                       __nagios_clients_tor |join(', ') }}
        #         service_description             Tor OrPort
        #         check_command                   check_tcp!8443
        #         notifications_enabled           1
        # }
        define service{
                use                             local-service
                host_name                       {{ nagios_clients_http |join(', ') }}
                service_description             HTTP
                check_command                   check_tcp!80
                notifications_enabled           0
        }
        define service{
                use                             local-service
                host_name                       {{ nagios_clients_http |join(', ') }}
                service_description             HTTPS
                check_command                   check_tcp!443
                notifications_enabled           0
        }
        define service{
                use                             local-service
                host_name                       {{ nagios_clients_mail |join(', ') }}
                service_description             IMAP
                check_command                   check_imap
                notifications_enabled           0
        }
        define service{
                use                             local-service
                host_name                       {{ nagios_clients_mail |join(', ') }}
                service_description             IMAPS
                check_command                   check_imaps
                notifications_enabled           0
        }
        define service{
                use                             local-service
                host_name                       {{ nagios_clients_mail |join(', ') }}
                service_description             SMTP
                check_command                   check_smtp
                notifications_enabled           0
        }
        define service{
                use                             local-service
                host_name                       {{ nagios_clients_mail |join(', ') }}
                service_description             SMTPS
                check_command                   check_smtps
                notifications_enabled           0
        }
        define service{
                use                             local-service
                host_name                       {{ nagios_clients_mail |join(', ') }}
                service_description             SSMTP
                check_command                   check_ssmtp
                notifications_enabled           0
        }
        # WEB CHECKS
        define service{
                use                             local-service
                host_name                       {{ nagios_clients_http |join(', ')  }}
                service_description             HTTP basic vhost HTML
                check_command                   check_http!{{ dns_name }}/index.html
                notifications_enabled           0
        }
        define service{
                use                             local-service
                host_name                       {{ nagios_clients_http |join(', ')  }}
                service_description             HTTP basic vhost PHP
                check_command                   check_http!{{ dns_name }}/index.php
                notifications_enabled           0
        }
        define service{
                use                             local-service
                host_name                       {{ nagios_clients_wiki |join(', ')  }}
                service_description             HTTP wiki
                check_command                   check_http!{{ dokuwiki_dns_name }}/
                notifications_enabled           0
        }
        define service{
                use                             local-service
                host_name                       {{ nagios_clients_wiki |join(', ')  }}
                service_description             HTTP repo
                check_command                   check_http!{{ repo_dns_name }}/
                notifications_enabled           0
        }
        define service{
                use                             local-service
                host_name                       {{ nagios_clients_owncloud |join(', ')  }}
                service_description             HTTP repo
                check_command                   check_http!{{ owncloud_dns_name }}/
                notifications_enabled           0
        }
        define service{
                use                             local-service
                host_name                       {{ nagios_servers |join(', ')  }}
                service_description             HTTP nagios
                check_command                   check_http!{{ nagios_dns_name }}/
                notifications_enabled           0
        }
        define service{
                use                             local-service
                host_name                       {{ zabbix_servers |join(', ')  }}
                service_description             HTTP zabbix
                check_command                   check_http!{{ zabbix_dns_name }}/
                notifications_enabled           0
        }
        define service{
                use                             local-service
                host_name                       {{ nagios_clients_http |join(', ')  }}
                service_description             HTTPS basic vhost
                check_command                   check_https_url
                notifications_enabled           0
        }
        define service{
                use                             local-service
                host_name                       {{ nagios_clients_http |join(', ')  }}
                service_description             HTTPS cert expiry in next 30 days
                check_command                   check_https_cert_expiry!{{ dns_name }}
                notifications_enabled           0
        }
        define service{
                use                             local-service
                host_name                       {{ nagios_clients_http |join(', ')  }}
                service_description             HTTP HA IP check
                check_command                   check_http!{{ bgp_ha_ip }}/
                notifications_enabled           0
        }
      marker: "# {mark} ANSIBLE MANAGED BLOCK - nagios services"
      create: true
      backup: yes

  - name: nagios - configure guest services
    blockinfile:
      dest: /etc/nagios/objects/localhost.cfg
      block: |
        define service{
                use                             local-service
                host_name                       {{ item.value.nagios_guest_host }}
                service_description             HTTP {{ item.value.nagios_guest_host }}
                check_command                   check_http!{{ item.value.nagios_guest_host }}
                notifications_enabled           0
        }
      marker: "# {mark} ANSIBLE MANAGED BLOCK - nagios guest {{ item.key }} services"
      create: true
      backup: yes
    no_log: true
    with_dict: '{{ nagios_guests }}'

  - name: nagios - configure guest https services
    blockinfile:
      dest: /etc/nagios/objects/localhost.cfg
      block: |
        define service{
                use                             local-service
                host_name                       {{ item.value.nagios_guest_host }}
                service_description             HTTPS {{ item.value.nagios_guest_host }}
                check_command                   check_https_url!{{ item.value.nagios_guest_host }}
                notifications_enabled           0
        }
        define service{
                use                             local-service
                host_name                       {{ item.value.nagios_guest_host }}
                service_description             HTTPS cert expiry in next 30 days
                check_command                   check_https_cert_expiry!{{ item.value.nagios_guest_host }}
                notifications_enabled           0
        }
      marker: "# {mark} ANSIBLE MANAGED BLOCK - nagios guest https {{ item.key }} services"
      create: true
      backup: yes
    no_log: true
    when: item.value.nagios_monitor_tls == true
    with_dict: '{{ nagios_guests }}'

  - name: nagios - configure guest ssh services
    blockinfile:
      dest: /etc/nagios/objects/localhost.cfg
      block: |
        define service{
                use                             local-service
                host_name                       {{ item.value.nagios_guest_host }}
                service_description             SSH
                check_command                   check_tcp!22
                notifications_enabled           0
        }
      marker: "# {mark} ANSIBLE MANAGED BLOCK - nagios guest ssh {{ item.key }} services"
      create: true
      backup: yes
    no_log: true
    when: item.value.nagios_monitor_ssh == true
    with_dict: '{{ nagios_guests }}'

  - name: nagios - check config
    command: nagios -v /var/www/etc/nagios/nagios.cfg
    register: nagios_result
    ignore_errors: yes

  - name: nagios - handle failure
    action: fail msg="nagios.cfg check failed."
    when: nagios_result|failed

  - name: nagios - reload nagios
    service: name=nagios state=reloaded
    when: nagios_result is succeeded

  - name: nagios - started
    service: name=nagios state=started

  - name: nagios - enable
    shell: rcctl enable nagios

  - name: nagios - configure httpd vhost
    blockinfile:
      dest: /etc/httpd.conf
      block: |
        server {{ nagios_dns_name }} {
           alias nagios{{ node_number }}.wurstbot.com

           listen on egress port 80
           listen on lo port 80
           root "/nagios"
           authenticate with ".nagioshtaccess"

            directory {
                    index "index.php"
            }

            location "/cgi-bin/nagios/*.cgi" {
                    root { "/" }
                    fastcgi socket "/run/slowcgi.sock"
            }

            location "*.php*" {
                    fastcgi socket ":{{ php_port }}"
            }

            location "/nagios*" {
                    root { "/nagios", strip 1 }
            }

           location "/.well-known/acme-challenge/*" {
                no authenticate
                root "/acme"
                root strip 2
           }
        }
      create: false
      marker: "# {mark} ANSIBLE MANAGED BLOCK - nagios vhost"

  - name: httpd - configure httpd tls
    blockinfile:
      dest: /etc/httpd.conf
      insertafter: "alias nagios"
      block: |
           listen on lo tls port 443
           listen on egress tls port 443
           tls certificate "/etc/ssl/{{ dns_name }}.crt"
           tls key "/etc/ssl/private/{{ dns_name }}.key"
           tls ocsp "/etc/ssl/{{ dns_name }}.der"
           # block return 301 "https://$HTTP_HOST$REQUEST_URI"
           # hsts
      create: true
      marker: "# {mark} ANSIBLE MANAGED BLOCK - dovecot vhost tls"
    when: use_tls==True

  - name: nagios - check httpd config
    command: /usr/sbin/httpd -n
    register: httpd_result
    ignore_errors: yes

  - name: nagios - handle httpd failure
    action: fail msg="httpd.conf check failed."
    when: httpd_result|failed

  - name: nagios - reload httpd when config changed
    service: name=httpd state=reloaded
    when: nagios_result is succeeded and httpd_result is succeeded


  #######################################
  # MariaDB
  #######################################
- name: configure mysql
  hosts: mysql_hosts
  user: admin
  become: true
  become_method: doas

  tasks:
  - name: mysql - install
    openbsd_pkg: name={{ item }} state=present
    with_items:
      - mariadb-server-{{ mysql_version }}
      - mariadb-client-{{ mysql_version }}
      - php-mysql
      - php-mysqli-{{ php_version }}
      # on bsd
      - py-mysql-{{ py_mysql_version }}
      # - python-mysqldb on linux
    register: mysql_install_results

  - name: mysql - install_db
    shell: mysql_install_db
    ignore_errors: true
    when: mysql_install_results|changed

  - name: mysql - configure .my.cnf listener
    lineinfile:
      dest: /etc/my.cnf
      line: listen on {{ node_ip }}
      insertafter: ^[mysqld]
    register: mysql_client_listener_results

  - name: mysql - configure .my.cnf client config
    blockinfile:
      dest: /etc/my.cnf
      block: |
        [client]
        user=root
        password={{ mysql_root_pass }}
      backup: yes
      create: true
      marker: "# {mark} ANSIBLE MANAGED BLOCK - mysql client config"
    register: mysql_client_config_results

  - name: mysql - started
    service: name=mysqld state=started

  - name: mysql - enable
    shell: rcctl enable mysqld

  - name: mysql - update root password
    mysql_user: check_implicit_admin=yes user=root host={{ item }} password={{ mysql_root_pass }} login_user=root login_password={{ mysql_root_pass }} host={{ node_ip }} state=present
    with_items:
      - localhost
      - "{{ ansible_hostname }}"

  - name: mysql - remove anonymous user(s) not in the database
    mysql_user: name='' host={{ item }} login_user=root login_password={{ mysql_root_pass }} state=absent
    with_items:
      - localhost
      - "{{ ansible_hostname }}"

  - name: mysql - remove the test database
    mysql_db: name=test login_user=root login_password={{ mysql_root_pass }} state=absent

    #to be fixed:
    # replication only granted for localhost
    # | 'zabbix_slave'@'localhost'  | def           | REPLICATION SLAVE       | NO           |

    # show call grants: select * from information_schema.user_privileges;

    #replication user name is "database_slave"
  - name: mysql - grant replication privileges to {{ item }}_slave for replicated dbs
    mysql_user: user={{ item }}_slave password={{ mysql_repl_pass }} priv="*.*:REPLICATION SLAVE" login_user=root login_password={{ mysql_root_pass }} host={{ node_ip }} state=present
    with_items: '{{mysql_repl_dbs}}'
    when: mysql_is_master
    register: mysql_grant_replication_result

  - name: mysql - master - update my.cnf to do bin-logging with to be replicated dbs
    lineinfile:
      dest: /etc/my.cnf
      line: "binlog_do_db  = {{ item }}"
      insertafter: "^log-bin="
      backup: yes
      create: true
    with_items: '{{mysql_repl_dbs}}'
    when: mysql_is_master and mysql_grant_replication_result is succeeded
    register: mysql_repl_config_results

    # mysql slave: needs to be set to inital log postion manually of with ansible mysql_replication module
    # create database databasename;
    # start slave;
    # show slave status\G

  # - name: mysql - check config
  #   command: mysqld --help --verbose
  #   register: mysqld_result
  #   ignore_errors: yes
  #
  # - name: mysql - handle failure
  #   action: fail msg="my.cnf check failed."
  #   when: mysql_result|failed

  - name: mysql - restart mysqld
    service: name=mysqld state=restarted
    when: ( mysql_client_listener_results|changed ) or ( mysql_client_config_results|changed ) or ( mysql_repl_config_results|changed )
